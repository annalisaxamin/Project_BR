---
title: "Project Bioinformatic Resources"
author: "Annalisa Xamin, Nicola Perotti"
output:
  pdf_document:
    latex_engine: xelatex
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      message=FALSE,
                      tidy.opts=list(width.cutoff = 80),
                      tidy = TRUE,
                      fig.align = "center"
                      )

# Set working directory
setwd("~/Documents/Repo_Git/Project_BR")
```


# Introduction
The following analysis focus on RNA-seq count data extracted from different cancer datasets from the Cancer Genome Atlas (TCGA). From the original TCGA data 50 cases (tumor samples) and 50 controls (normal samples) were randomly selected.

# Analysis
The packages needed for the analysis are the following:
```{r load libraries, results='hide'}
library(tidyverse)
library(biomaRt)
library(MotifDb) # large collection of motifs across different species
library(seqLogo) 
library(PWMEnrich)
library(PWMEnrich.Hsapiens.background)
library(GEOquery)
library(oligo)
library(pd.hg.u133.plus.2)
library(hgu133plus2.db)
library(genefilter)
library(limma)
library(pheatmap)
library(stringr)
library(GenomicFeatures) # to build object with specific information such as genomic coordinates
library(ggplot2)
library(edgeR) # designed to perform Differential Expression Analysis from RNA-Seq data
library(fgsea) # computation of enrichment scores and other statistics
library(org.Hs.eg.db) # database annotation human specific transcript from Ensembl
library(clusterProfiler) # uses Fisher test, explore gene list of interest against a reference
library(enrichplot) # build enrich map
library(ggnewscale)
library(DOSE)
library(pathview) # contains cartoons of pathways and we project on them our genes of interest
library(igraph)
```

## Task 1: Load data
In particular, we consider data coming from **Lung adenocarcinoma**.
```{r Load data}
load("./RData/Lung_adenocarcinoma.RData")
```
After loading the data, the following three data-frames are available:

- `raw_counts_df` which contains the raw RNA-seq counts;

- `c_anno_df`, which contains sample name and condition (case and control);

- `r_anno_df`, which contains the ENSEMBL genes ids, the length of the genes and the genes symbols.

```{r explore raw_counts_df, include=FALSE}
# Explore only the first 5 rows of the data frame
head(raw_counts_df, n=5)
head(rownames(raw_counts_df), n=5)
head(colnames(raw_counts_df), n=5)
```

```{r explore c_anno_df, include = FALSE}
# Explore only the first 5 rows of the data frame
head(c_anno_df, n = 5)
head(rownames(c_anno_df), n=5)
head(colnames(c_anno_df)) # there are only 2 columns: sample and condition
```

```{r explore r_anno_df, include = FALSE}
# Explore only the first 5 rows of the data frame
head(r_anno_df, n = 5)
head(rownames(r_anno_df), n=5)
head(colnames(r_anno_df)) # there are only 3 columns: ensembl_gene_id, external_gene_name, length
```

## Task 2: Filter protein coding genes
To extract only protein coding genes from `raw_counts_df` and `r_anno_df`, we use the `biomaRt` package.

First, we retrieve the information about the protein coding genes from Ensembl.
```{r extract protein coding genes}
database <- useMart("ensembl")
datasetHuman <- useDataset("hsapiens_gene_ensembl",mart=database)
query <- getBM(attributes=c("ensembl_gene_id",
                            "external_gene_name",
                            "gene_biotype"),
                filters = c("ensembl_gene_id"), 
                values = r_anno_df$ensembl_gene_id,
                mart = datasetHuman)

query_protein_coding <- query[which(query$gene_biotype == "protein_coding"), ]
```

```{r inspect query_protein_coding, include=FALSE}
query_protein_coding
```

Then, we filter the data frames containing the raw counts and the annotation to keep only the protein coding genes.
```{r raw_counts r_anno df protein coding}
indexes_r_anno_df <- which(r_anno_df$ensembl_gene_id %in% query_protein_coding$ensembl_gene_id)
r_anno_df_protein_coding <- r_anno_df[indexes_r_anno_df, ]

indexes_raw_counts_df <- which(rownames(raw_counts_df) %in% query_protein_coding$ensembl_gene_id)
raw_counts_df_protein_coding <- raw_counts_df[indexes_raw_counts_df, ]
```

## Task 3: Differential expression analysis
To perform the differential expression analysis, we will use the `edgeR` package. 

It is important to remove genes with low signal that will have low statistical power. Since, we want to focus on the transcripts we can use to perform the analysis, we can filter raw counts data using a threshold of raw count > 20 in at least 5 replicates.
```{r filtering}
# count threshold
count_thr <- 20

# number of replicates with more counts than the count threshold
repl_thr <- 5

filter_vec <- apply(raw_counts_df_protein_coding,1, # go through all count matrices by rows
    function(y) max(by(y, c_anno_df$condition, function(x) sum(x>=count_thr))))
    # groups the values on each condition and sum all the values above the count
```

```{r see statistics for the filtering, include=FALSE}
table(filter_vec)
```

Then, we filter the previously updated data frames.
```{r create filtered df }
filter_counts_df <- raw_counts_df_protein_coding[filter_vec>=repl_thr,]
dim(filter_counts_df) # 17289

filter_anno_df <- r_anno_df_protein_coding[rownames(filter_counts_df),]
dim(filter_anno_df) # 17289
```

Now we check the library size of each sample (how many reads we have sequenced for each experiment)
```{r check library size of each sample, fig.cap="Library size of each sample."}
size_df <- data.frame("sample"=colnames(filter_counts_df), "read_millions"=colSums(filter_counts_df)/1000000) 

ggplot(data=size_df,aes(sample,read_millions)) +
  geom_bar(stat="identity",fill="indianred",colour="indianred",width=0.7,alpha=0.7)+
  coord_flip()+
  theme_bw()
```
Then, we visualize a boxplot of gene counts.
```{r boxplot gene counts, fig.cap="Boxplot of gene counts before normalization."}
long_counts_df <- gather(as.data.frame(filter_counts_df), key = "sample", value = "read_number")

ggplot(data=long_counts_df,aes(sample,read_number+1)) + 
  geom_boxplot(colour="deeppink4",fill="deeppink4",alpha=0.7) +
  theme_bw() +
  scale_y_log10()
```

As we can see from the plots, there is a significant variability across samples in term of library sizes (reads per million). We have to take into account this aspect because the expected size of each count is the product of the relative abundance of that gene in that sample but also of the library size.

As we can see from the boxplot, we need to normalize our data before testing for differential expression. Normalization can be obtained using different methodologies. Among them, TMM (the default method) is a method that consider in the normalization also variables related to the library size.

To perform the DEG analysis, we first need to create a DGRList object containing information about counts, annotation, samples and genes. To do that, we use the function `DGEList` to create the input for the following normalization step. This object contains information about counts, samples and genes.

The normalization intra- and inter-sample is done using the function `calcNormFactors` and specifying `method = "TMM"`, which is the weighted trimmed mean of M-values approach. 

```{r TMM normalization}
edge_c <- DGEList(counts=filter_counts_df,group=c_anno_df$condition,samples=c_anno_df,genes=filter_anno_df)

# computing norm factors for TMM normalization
edge_n <- calcNormFactors(edge_c,method="TMM")
```

Then, we create a cpm table containing the normalized expression values for each transcript expressed as counts per million (CPM).
```{r cpm_table}
# create a cpm table (normalized expression values)
cpm_table <- as.data.frame(round(cpm(edge_n),2))
```

```{r inspect cpm_table, include=FALSE}
head(cpm_table)
```

To see the effect of the normalization, we look at the boxplot distribution of gene expression signals after normalization.
```{r boxplot distribution of gene expression signals after normalization, fig.cap="Boxplot distribution of gene expression signals after normalization."}
# look at the boxplot distribution of gene expression signals after normalization
long_cpm_df <- gather(cpm_table, key = "sample", value = "CPM")

ggplot(data=long_cpm_df,aes(sample,CPM+1)) +
   geom_boxplot(colour="olivedrab",fill="olivedrab",alpha=0.7)+
   theme_bw()+
   scale_y_log10() 
```

We notice that, with respect to the previous boxplot, after the normalization, the distributions are comparable. That means that now our data is ready to be tested for DE analysis.

We define the experimental design matrix, later needed to calculate the dispersion and fit. This matrix is based on the experimental design, so we define the conditions we want to test (case VS control).
```{r define experimental design matrix}
design <- model.matrix(~0+group, data=edge_n$samples)
colnames(design) <- levels(edge_n$samples$group)
rownames(design) <- edge_n$samples$sample
```

```{r inspect design, include=FALSE}
design
```

Once we normalized the data and the design, we proceed by calculating the dispersion fit.
```{r dispersion and fit}
# calculate dispersion and fit with edgeR (necessary for differential expression analysis)
edge_d <- estimateDisp(edge_n,design)
edge_f <- glmQLFit(edge_d,design) 
```

The `estimateDisp` function tries to estimate the variability at different levels: in the data, inter sample and intra sample. The over dispersion of counts across the samples can be modeled as a Poisson distribution, which can be approximated using a negative binomial distribution by using `glmQLFit` function.

```{r estimated values of the GLM, include=FALSE}
# glmQLFit returns an object containing the estimated values of the GLM coefficients for each gene:
head(edge_f$coefficients)
```

We define the contrasts (conditions to be compared).
```{r define contrasts}
contro <- makeContrasts("control-case", levels=design)
```


We performed a test through function `glmQLFTest` to determine which genes are differentially expressed. Then, we selected genes based on a 0.01 p-value cutoff and ordered them based on the log2 fold change.
```{r fit the model with generalized linear models}
# fit the model with generalized linear models
edge_t <- glmQLFTest(edge_f,contrast=contro)
DEGs <- as.data.frame(topTags(edge_t, n=20000, p.value = 0.01, sort.by = "logFC")) 
```

Then, we improve the selection, considering not only the p-value, but also the average expression of the genes (logCPM). We used the logFC value to assign genes to different classes:

- up-regulated genes if $logFC>1.5$

- down-regulated genes if $logFC<-1.5$

- not significant genes (unchanged) otherwise.

```{r}
DEGs$class <- "="
DEGs$class[which(DEGs$logCPM>1&DEGs$logFC>1.5&DEGs$FDR<0.25)] = "+" # upregulated genes
DEGs$class[which(DEGs$logCPM>1&DEGs$logFC<(-1.5)&DEGs$FDR<0.25)] = "-" # downregulated genes
DEGs <- DEGs[order(DEGs$logFC,decreasing = T),]
```

```{r check how many up and down regulated}
head(DEGs)
table(DEGs$class) # 1193-, 877+, 14949= 
```

From the results, we saw that 1193 genes are down-regulated, 877 genes are up-regulated and 14949 genes have no changes in their regulation.

We then create the volcano plot.
```{r volcano plot, fig.cap="Volcano plot"}
input_df <- DEGs
xlabel <- "log2 FC case vs control"
ylabel <- "-log10 p-value"

par(fig=c(0,1,0,1), mar=c(4,4,1,2), mgp=c(2, 0.75, 0))	
plot(input_df$logFC, -log(input_df$PValue,base=10),xlab=xlabel, ylab=ylabel, 
     col=ifelse(input_df$class=="=","grey70","olivedrab4"), pch=20, frame.plot=TRUE, cex=0.8, main="Volcano plot")
abline(v=0,lty=2,col="grey20")
```

The volcano plot allows to have a quick visual identification of genes with large fold changes that are also statistically significant.

We also report the heatmap of only up and down-regulated genes. 

To create an annotated heatmap focusing only on up- and down-regulated genes we need first of all a matrix in which we select genes with class "+" or "-. Moreover, we also need to assign a color to each sample. In this case, we assign green to the case condition and beige to the control, and save the corresponding color into the variable `cols`. In this way, we can then set the `ColSideColors` parameter in order to have a color code to recognize the sample condition.
```{r heatmap, fig.cap="Heatmap up and down-regulated genes."}
# plot only up and down regulated genes
cols <- c(ifelse(c_anno_df$condition == "case", "chartreuse4","burlywood3"))
pal <- c("blue","white","red") 
pal <- colorRampPalette(pal)(100)
heatmap(as.matrix(cpm_table[which(rownames(cpm_table)%in%DEGs$ensembl_gene_id[which(DEGs$class!="=")]),]),
        ColSideColors = cols,cexCol = 0.5,margins = c(4,4),col=pal,cexRow = 0.2)
```

On the top of the heatmap, we can see the dendrogram indicating how distant our samples are, while on the left the dendrogram related to genes. The dendogram is built by hierarchical clustering, a method based on the concept of dissimilarity. 

To simplify the later analysis, we save the list of differentially expressed genes in a text file.
```{r save up and down regulated in text file}
up_DEGs <- DEGs[which(DEGs$class=="+"),]
down_DEGs <- DEGs[which(DEGs$class=="-"),]

write.table(up_DEGs,file="output/up_DEGs.txt",row.names=F,col.names=T,sep="\t",quote=F)
write.table(down_DEGs,file="output/down_DEGs.txt",row.names=F,col.names=T,sep="\t",quote=F)
write.table(DEGs,file="output/DEGs.txt",row.names=F,col.names=T,sep="\t",quote=F)
```


## Task 4: Gene set enrichment analysis
To perform the gene set enrichment analysis, we will use the `clusterProfiler` package.

```{r import the previously saved DEGs}
DEGs <- read.table("output/DEGs.txt",header=T,sep="\t",as.is=T)
table(DEGs$class)
```

We use the `biomaRt` package to retrieve the `entrezgene_id` for all the genes in the `DEGs` dataset.

```{r}
ensembl <- useEnsembl(biomart = "ensembl",dataset = "hsapiens_gene_ensembl")
convert <- getBM(attributes=c("ensembl_gene_id","entrezgene_id"),
                 filters=c("ensembl_gene_id"), 
                 values=DEGs$ensembl_gene_id,
                 mart = ensembl)

DEGs <- merge(DEGs,convert,by.x="ensembl_gene_id",by.y="ensembl_gene_id") # include the new info in the original data frame
DEGs <- DEGs[which(!is.na(DEGs$entrezgene_id)),]
DEGs <- DEGs[-which(duplicated(DEGs$entrezgene_id)),]
```

We removed all the NA and duplicates in the dataset DEGs.

We created new lists for the down and up-regulated genes.
```{r}
# list of up-regulated genes
upDEGs <- DEGs %>% filter(class == "+")
# list of down-regulated genes
downDEGs <- DEGs %>% filter(class == "-")
```

### Performing enrichment analysis for GO biological process
```{r BP up regulated}
# biological process up regulated genes
ego_BP_up <- enrichGO(gene = upDEGs$external_gene_name,
                   OrgDb = org.Hs.eg.db,
                   keyType = 'SYMBOL',
                   ont = "BP",
                   pAdjustMethod = "BH",
                   pvalueCutoff = 0.05,
                   qvalueCutoff = 0.05)
```

```{r BP down regulated}
# biological process down regulated genes
ego_BP_down <- enrichGO(gene = downDEGs$external_gene_name,
                   OrgDb = org.Hs.eg.db,
                   keyType = 'SYMBOL',
                   ont = "BP",
                   pAdjustMethod = "BH",
                   pvalueCutoff = 0.05,
                   qvalueCutoff = 0.05)
```

We report the top 10 enriched GO terms related to the Biological Process for both up and down regulated genes.\
In the barplots we can see that the elements are ordered by adjusted p-value (where the most significant is placed on the top) and on the x-axis we have the gene counts, so the number of elements of our lists were found in the category.

```{r barplot BP up, fig.cap="Biological process up regulated genes"}
barplot(ego_BP_up,showCategory=10, main = "Up-regulated gene list: top 10 enriched BP terms")
```

Both the first two biological processes are related to the microtubules, which might be explained by the fact that tumour cells have a high growth rate thus the cytoskeleton is assembled over and over again. We also notice that angiogenesis is among the most enriched biological processes as we expected. In fact, angiogenesis is particularly important in tumorigenesis to allow the growth of the tumour tissue, providing nutrients to cells.

```{r barplot BP down, fig.cap="Biological process down regulated genes"}
barplot(ego_BP_down,showCategory=10, main= "Down-regulated gene list: top 10 enriched BP terms")
```

We would expect most of these biological processes to be enriched in the up-regulated genes since tumour cells tend to replicate more than normal cells. A possible explaination is that tumour cells genes accumulate numerous mutations usually ending up in loss of function or downregulation. These mutations might occur on transcription factors binding sites or RNA binding sites, reducing their expression.

### Performing enrichment analysis for GO molecular function
The same analysis was done also for the molecular function.
```{r MP up regulated}
# molecular function up regulated genes
ego_MF_up <- enrichGO(gene = upDEGs$external_gene_name,
                   OrgDb = org.Hs.eg.db,
                   keyType = 'SYMBOL',
                   ont = "MF",
                   pAdjustMethod = "BH",
                   pvalueCutoff = 0.05,
                   qvalueCutoff = 0.05)
```

```{r MP down regulated}
# molecular function down regulated genes
ego_MF_down <- enrichGO(gene = downDEGs$external_gene_name,
                   OrgDb = org.Hs.eg.db,
                   keyType = 'SYMBOL',
                   ont = "MF",
                   pAdjustMethod = "BH",
                   pvalueCutoff = 0.05,
                   qvalueCutoff = 0.05)
```

```{r visualize MF up, fig.cap="Molecular function up regulated genes"}
barplot(ego_MF_up,showCategory=10, main = "Up-regulated gene list: top 10 enriched MP terms")
```

```{r visualize MF down, fig.cap="Molecular function down regulated genes"}
barplot(ego_MF_down,showCategory=10, main = "Down-regulated gene list: top 10 enriched MP terms")
```

```{r WP up regulated}
eWP_up <- enrichWP(gene = upDEGs$entrezgene_id,
                    organism = 'Homo sapiens',
                    pvalueCutoff = 0.05,
                    qvalueCutoff = 0.1)

head(eWP_up, n=10)
```

```{r WP down regulated}
eWP_down <- enrichWP(gene = downDEGs$entrezgene_id,
                    organism = 'Homo sapiens',
                    pvalueCutoff = 0.05,
                    qvalueCutoff = 0.1)

head(eWP_down, n=10)
```

```{r save enrichment plot, include=FALSE}
get_enrich_plots <- function(df){
  show(dotplot(df, showCategory = 10))
}

# Saving enrichment plots
pdf("output/ego_BP_up.pdf")
get_enrich_plots(ego_BP_up)
dev.off()
pdf("output/ego_MF_up.pdf")
get_enrich_plots(ego_MF_up)
dev.off()
pdf("output/eWP_up.pdf")
get_enrich_plots(eWP_up)
dev.off()
pdf("output/ego_BP_down.pdf")
get_enrich_plots(ego_BP_down)
dev.off()
pdf("output/ego_MF_down.pdf")
get_enrich_plots(ego_MF_down)
dev.off()
pdf("output/eWP_down.pdf")
get_enrich_plots(eWP_down)
dev.off()
```


## Task 5: Visualization of the enriched pathway
KEGG analysis was performed using the function `enrichKEGG`.
```{r KEGG, warning=FALSE}
eWP_KEGG <- enrichKEGG(gene = upDEGs$entrezgene_id,
                    organism = 'human',
                    pvalueCutoff = 0.05,
                    qvalueCutoff = 0.1)
```

Here are reported the top 10 enriched KEGG pathways resulting from the up-regulated list of genes.
```{r}
knitr::kable(head(eWP_KEGG[, 1:6], n=10))
```

The more enriched pathway (using the list of up-regulated genes) is related to malaria (and has ID `hsa05144`). We then visualized it using the package `pathview`:
```{r pathview up regulated, warning=FALSE}
# set working directory to save output
setwd("~/Documents/Repo_Git/Project_BR/output")

logFC <- upDEGs$logFC
names(logFC) <- upDEGs$entrezgene_id
pathview(gene.data = logFC, 
         pathway.id = "hsa05144", 
         species = "human")
```

Here is reported the network representing the pathway, with the up-regulated genes colored in red:

![Most enriched pathway](~/Documents/Repo_Git/Project_BR/output/hsa05144.pathview.png)

## Task 6: Enrichment score transcription factors
First of all, we retrieve the promoter sequence for all the genes in the list of those down-regulated using ensembl gene id as identifier.
```{r retrieve promoter regions}
promoter_regions <- getSequence(id=downDEGs$ensembl_gene_id,
                    type="ensembl_gene_id",
                    seqType="gene_flank",
                    upstream = 500,
                    mart=ensembl)
```

Then we load the background for MotifDb human PWMs and convert the obtained sequence into a DNAString object. 
```{r}
data(PWMLogn.hg19.MotifDb.Hsap)
seq <- lapply(promoter_regions$gene_flank, function(x) DNAString(x))
```

`motifEnrichment` function performs enrichment analysis on the promoter sequences we obtained a few chunks above.
```{r enriched TFs, warning=FALSE}
enriched_TFs = motifEnrichment(seq,PWMLogn.hg19.MotifDb.Hsap,score = "affinity")
```
```{r visulize output enriched TFs, include=FALSE}
enriched_TFs
```
```{r}
report = groupReport(enriched_TFs)
```
```{r inspect report, include=FALSE}
report
```

Here we plot the top 5 enriched transcription factors resulted from our analysis:
```{r}
plot(report[1:5])
```

## Task 7
We select one among the top enriched TFs (TFAP4), compute the empirical distributions of scores for all PWMs that you find in MotifDB for the selected TF and determine for all of them the distribution (log2) threshold cutoff at 99.75%.

```{r, warning=FALSE}
tfs <- report$target[2] # contains TFAP4
tfs_motifs = subset(MotifDb, organism == "Hsapiens" & geneSymbol == tfs)

# transformation to a PWM matrix
PWM = toPWM(as.list(tfs_motifs))
```

For the selected TF we found 15 PWMs:

- Hsapiens-cisbp_1.02-M2943_1.02

- Hsapiens-cisbp_1.02-M2944_1.02

- Hsapiens-cisbp_1.02-M2947_1.02

- Hsapiens-cisbp_1.02-M5926_1.02

- Hsapiens-cisbp_1.02-M5927_1.02

- Hsapiens-cisbp_1.02-M6513_1.02

- Hsapiens-HOCOMOCOv10-TFAP4_HUMAN.H10MO.C

- Hsapiens-HOCOMOCOv11-core-A-TFAP4_HUMAN.H11MO.0.A

- Hsapiens-jaspar2016-TFAP4-MA0691.1

- Hsapiens-jaspar2018-TFAP4-MA0691.1

- Hsapiens-jaspar2022-TFAP4-MA0691.1

- Hsapiens-jaspar2022-TFAP4-MA1570.1

- Hsapiens-jolma2013-TFAP4

- Hsapiens-jolma2013-TFAP4-2

- Hsapiens-SwissRegulon-TFAP4.SwissRegulon

```{r visualize PWM, include=FALSE}
PWM
```

To get the empirical distribution we used the function `motifEcdf`, which associates to each PWM a distribution. Then, for each score we computed the scores with a cutoff threshold of 99.75%.
```{r, warning=FALSE}
ecdf = motifEcdf(PWM, organism = "hg19", quick = TRUE)

thresholds = lapply(ecdf, function(x) log2(quantile(x, 0.9975))) 
# for each of the distribution, take the quantile as reference

scores = motifScores(seq, PWM, raw.scores = FALSE, cutoff = unlist(thresholds))
```

In the following table are reported the calculated scores for each PWM of the first 10 motifs.
```{r}
head(scores, n=10)
```

## Task 8: Pattern matching
We identify which down-regulated genes have a region in their promoter (defined as previously) with binding scores above the computed thresholds for any of the previously selected PWMs.

To do that, we using the table of scores displayed before. We selected only genes having a region in their promoter with binding scores above the computed thresholds for any of the previously selected PWMs.
```{r}
fractions_99.75 <- c()
fractions_99.75 <- c(fractions_99.75, length(which(apply(scores, 1, sum)>0))/length(scores))
fractions_99.75

highscore_seq <- which(apply(scores,1,sum)>0)
genes_id <- downDEGs[highscore_seq,]
```

```{r, include=FALSE}
#highscore_seq <- which(apply(scores, 1, function(x) { sum(x == 0)}) == 0)
#genes_id <- downDEGs[highscore_seq,]
#length(genes_id)
```

The resulting list contains 10 genes.
```{r}
length(genes_id)
```

```{r}
genes_id
```


```{r save output task 8, include=FALSE}
write(genes_id, 'output/enriched_genes_id.txt')
```

## Task 9: PPI interactions
We use STRING database to ind PPI interactions among differentially expressed genes. The network is exported in TSV format.
```{r}
dat <- read.table("output/down_DEGs.txt", sep = "\t", header = TRUE)

write.table(dat$ensembl_gene_id, file = "output/ens_gene_id_down.txt", row.names = FALSE, col.names = FALSE)
```


## Task 10: visualize the network
We import the network in R and, using `igraph` package, we identify and plot the largest connected component.
```{r}
links_high_conf <- read.delim("data_STRING/string_interactions_short_high_conf.tsv")
links <- read.delim("data_STRING/string_interactions_short.tsv")
downDEGs <- read.table("output/down_DEGs.txt", sep = "\t", header = TRUE)

ensembl <- useMart(biomart="ensembl",dataset="hsapiens_gene_ensembl")
nodes <- 
   getBM(attributes=c("external_gene_name","ensembl_gene_id","description","gene_biotype","start_position","end_position","chromosome_name","strand"),
         filters=c("ensembl_gene_id"), 
         values=downDEGs[,1],
         mart = ensembl) # search info about nodes using ensembl_gene_id
nodes <- unique(nodes[,c(1,3:6)])

nodes <- nodes[nodes$external_gene_name %in% links$X.node1 & nodes$external_gene_name %in% links$X.node1,]

links <- links[links$X.node1 %in% nodes$external_gene_name & links$node2 %in% nodes$external_gene_name,]

# create network
net <- graph_from_data_frame(d=links,vertices=nodes,directed=FALSE)

plot(net)

c <- components(net, mode = c("weak","strong"))
net.c <- induced_subgraph(net,V(net)[which(c$membership==1)])

plot(net.c, 
     edge.width=2,
     vertex.color="orange",
     vertex.size=10,
     vertex.frame.color="darkgray",
     vertex.label.color="black", 
     vertex.label.cex=0.7,
     edge.curved=0.1)


deg <- degree(net.c,mode="all")
names_nodes <- names(deg[which(deg>150)])

nodes.deg <- nodes[nodes$external_gene_name %in% names_nodes,]

nodes.deg <- nodes.deg[nodes.deg$external_gene_name %in% links$X.node1 & nodes.deg$external_gene_name %in% links$node2,]
links.deg <- links[links$X.node1 %in% nodes.deg$external_gene_name & links$node2 %in% nodes.deg$external_gene_name,]

net.deg <- graph_from_data_frame(d=links.deg,vertices=nodes.deg,directed=FALSE)

plot(net.deg, 
     edge.width=0.5,
     vertex.color="orange",
     vertex.size=10,
     vertex.frame.color="darkgray",
     vertex.label.color="black", 
     vertex.label.cex=0.7,
     edge.curved=0.1)
```

```{r string with higher confidence in settings}
links_high_conf <- read.delim("data_STRING/string_interactions_short_high_conf.tsv")
downDEGs <- read.table("output/down_DEGs.txt", sep = "\t", header = TRUE)

ensembl <- useMart(biomart="ensembl",dataset="hsapiens_gene_ensembl")
nodes <- 
   getBM(attributes=c("external_gene_name","ensembl_gene_id","description","gene_biotype","start_position","end_position","chromosome_name","strand"),
         filters=c("ensembl_gene_id"), 
         values=downDEGs[,1],
         mart = ensembl) # search info about nodes using ensembl_gene_id
nodes <- unique(nodes[,c(1,3:6)])

nodes <- nodes[nodes$external_gene_name %in% links_high_conf$X.node1 & nodes$external_gene_name %in% links_high_conf$X.node1,]

links_high_conf <- links_high_conf[links_high_conf$X.node1 %in% nodes$external_gene_name & links_high_conf$node2 %in% nodes$external_gene_name,]

# create network
net <- graph_from_data_frame(d=links_high_conf,vertices=nodes,directed=FALSE)

plot(net)

c <- components(net, mode = "strong")
net.c <- induced_subgraph(net,V(net)[which(c$membership==1)])

plot(net.c, 
     edge.width=2,
     vertex.color="orange",
     vertex.size=10,
     vertex.frame.color="darkgray",
     vertex.label.color="black", 
     vertex.label.cex=0.7,
     edge.curved=0.1)


deg <- degree(net.c,mode="all")
names_nodes <- names(deg[which(deg>110)])

nodes.deg <- nodes[nodes$external_gene_name %in% names_nodes,]

nodes.deg <- nodes.deg[nodes.deg$external_gene_name %in% links_high_conf$X.node1 & nodes.deg$external_gene_name %in% links_high_conf$node2,]
links.deg.high <- links_high_conf[links_high_conf$X.node1 %in% nodes.deg$external_gene_name & links_high_conf$node2 %in% nodes.deg$external_gene_name,]

net.deg <- graph_from_data_frame(d=links.deg.high,vertices=nodes.deg,directed=FALSE)

plot(net.deg, 
     edge.width=0.5,
     vertex.color="orange",
     vertex.size=10,
     vertex.frame.color="darkgray",
     vertex.label.color="black", 
     vertex.label.cex=0.7,
     edge.curved=0.1)
```

